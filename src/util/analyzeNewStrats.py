from os import listdir
from os.path import isfile, join
from src.GlobalVars import PATH
import numpy as np
import matplotlib.pylab as pl
import DataSet
from cPickle import dump, load


def get_strategy_file_names(path=join(PATH, 'contrib/males/E/resultsTmp')):
    return [f for f in listdir(path) if isfile(join(path, f))]


def get_strat_overlap():
    new_strats = get_strategy_file_names()
    old_strats = get_strategy_file_names(join(PATH, 'data/TESTRUNS_PEGASUS/'))
    return list(set(new_strats) & set(old_strats))


def load_new_strat(filename, path=join(PATH, 'contrib/males/E/resultsTmp/')):
    new_strat = {}
    firstline = True
    with open(path + filename, 'r') as inputstream:
        for line in inputstream:
            if firstline:
                firstline = False
            else:
                sline = line.split()
                new_strat[sline[0].split('/')[6]] = [float(sline[1])]
    return new_strat


def load_old_strat(filename, new_strat, path=join(PATH, 'data/TESTRUNS_PEGASUS/')):
    firstline = True
    both_strats = new_strat.copy()
    with open(path + filename, 'r') as inputstream:
        for line in inputstream:
            if firstline:
                firstline = False
            else:
                sline = line.split()
                if sline[0] in new_strat.keys():
                    if sline[1] == 'T':
                        both_strats[sline[0]].append(float(sline[2]))
                    else:
                        both_strats[sline[0]].append(-1)
    return both_strats


def get_all_probs(all_strats):
    all_keys = []
    for strat in all_strats:
        all_keys += strat.keys()
    return list(set(all_keys))


def load_strat_overlap_ratios():
    overlap = get_strat_overlap()
    all_strats = []
    for lap in overlap:
        new_strat = load_new_strat(lap)
        both_strats = load_old_strat(lap, new_strat)
        all_strats.append(both_strats)
    return all_strats, overlap


def generate_ratio_matrix(all_strats, strat_names, all_probs):
    # Ratios are generated by dividing the old value by the new value
    rat = np.zeros((len(all_probs), len(all_strats)))
    for i, strat in enumerate(all_strats):
        for j, prob in enumerate(all_probs):
            if prob in strat.keys():
                rat[j, i] = strat[prob][0] / strat[prob][1]
    return rat


def plot_distribution(ratio_mat):
    averages = []
    for line in ratio_mat:
        averages.append(np.average((line[line > 0])))
    pl.hist(averages, bins=15)
    pl.show()


def get_average_t_for_probs(all_strats, all_probs):
    times = []
    for prob in all_probs:
        for strat in all_strats:
            if prob in strat.keys():
                if strat[prob][0] > 0 and strat[prob][1] > 0:
                    times.append((strat[prob][0], (strat[prob][0] / strat[prob][1])))
    return np.array(times)


def get_average_t_for_probs_per_strat(all_strats, all_probs):
    times = []
    for strat in all_strats:
        strat_times = []
        for prob in all_probs:
            if prob in strat.keys():
                if strat[prob][0] > 0 and strat[prob][1] > 0:
                    strat_times.append((strat[prob][0], (strat[prob][0] / strat[prob][1])))
        times.append(strat_times)
    return times


def plot_scatter(times):
    pl.scatter(times[:, 0], times[:, 1])
    pl.xlabel('Time in seconds')
    pl.ylabel('Ratio')
    pl.title('Time in seconds versus the ratio')
    pl.xlim(0, 300)
    pl.xscale('log')
    pl.show()


def plot_scatter_per_strat(times):
    colors = ['r', 'b', 'g', 'y']
    for t, col in zip(times, colors):
        t_temp = np.array(t)
        pl.scatter(t_temp[:, 0], t_temp[:, 1], c=col)

    pl.xlabel('Time in seconds')
    pl.ylabel('Ratio')
    pl.title('Time in seconds versus the ratio')
    pl.xlim(0, 300)
    pl.show()


def load_solved_probs_by_e():  # NQQA
    ds = DataSet.DataSet()
    ds.load('E')
    strat = ds.strategy_matrix
    strat_names = ds.problems
    strat[strat > 0] = 1
    strat[strat < 0] = 0
    return strat_names[np.any(strat, 1)]


def find_new_solved():
    solved_E = load_solved_probs_by_e()
    all_strats, _ = load_strat_overlap_ratios()
    solved_males = get_all_probs(all_strats)
    return list(set(solved_males) - set(solved_E))


def plot_all_ratios():
    all_strats, strat_names = load_strat_overlap_ratios()
    all_probs = get_all_probs(all_strats)
    # _ratios = generate_ratio_matrix(all_strats, strat_names, all_probs)
    times = get_average_t_for_probs_per_strat(all_strats, all_probs)
    plot_scatter_per_strat(times)


def compare_two_strats(times1, times2):
    count_both_solve = 0
    count_solve_better = 0
    for i1, i2 in zip(times1, times2):
        if i1 != -1 and i2 != -1:
            count_both_solve += 1
            if i2 < i1:
                count_solve_better += 1
    return count_both_solve, count_solve_better


def compare_all_strats():
    ds = DataSet.DataSet()
    ds.load('E')
    old_times = ds.strategy_matrix
    print 'Old times: {}'.format(old_times.shape)
    all_strats, strat_names = load_strat_overlap_ratios()
    print 'all_strats: {}'.format(len(all_strats))
    print 'strat_names: {}'.format(len(strat_names))
    new_times = generate_ratio_matrix(all_strats, strat_names, ds.problems)
    print 'New times: {}'.format(new_times.shape)
    print 'Done loading times'
    for new_t in new_times.T:
        print new_t.shape
        for old_t in old_times.T:
            print old_t.shape
            print compare_two_strats(old_t, new_t)
            break
        break


def load_object(filename):
    handle = open(filename)
    data = load(handle)
    handle.close()
    return data


def save_object(obj, filename):
    handle = open(filename, 'w')
    dump(obj, handle)
    handle.close()
    return

ds = DataSet.DataSet()
ds.load('E')
all_probs = ds.problems
new_strats = get_strategy_file_names()
print 'Starting loading files'
new_strat_times = [load_new_strat(new_strat) for new_strat in new_strats]
print 'Done loading files'

results = np.empty((len(all_probs), len(new_strats)))
results[:] = -1
print results.shape
print results[:5, :5]

for col, new_strat in enumerate(new_strat_times):
    print col
    for row, p in enumerate(all_probs):
        if p in new_strat.keys():
            results[row, col] = new_strat[p][0]

print 'Done'

save_object(results, 'males_E_results.cpickle')
